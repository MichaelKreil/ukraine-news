<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="d3.min.js" charset="utf-8"></script>
		<style>
			body {
				font-family: sans-serif;
				font-size: 14px;
				margin-bottom: 100px;
			}
			h1 {
				text-align: center;
				margin: 100px 0 50px;
			}
			h2 {
				text-align: center;
				font-size: 18px;
				margin: 100px 0 0px;
			}
			p {
				max-width: 600px;
				margin: 30px auto;
				line-height: 1.3em
			}
			select {
				font-size: 20px;
			}
		</style>
	</head>
	<body>
		<h1>Wird uns der Krieg morgen noch interessieren?</h1>

		<p>Der Krieg in der Ukraine wird vorraussichtlich Monate oder sogar Jahre andauern. Weil viele Menschen nicht direkt betroffen sind, können wir davon ausgehen, dass in unserer Gesellschaft ein Gewöhnungseffekt eintreten wird. Im gleichen Maße wird die Berichterstattung abnehmen und andere Themen werden relevanter.
		<br>Diesen Effekt möchte ich beobachten und dabei unterschiedliche Medien in unterschiedlichen Ländern vergleichen.</p>

		<p>Dazu werden die Frontseiten zahlreicher Nachrichtenseiten täglich von archive.org geladen und die Häufigkeit thematischer Begriffe gezählt. Diese Begriffe sind (natürlich in der jeweiligen Landessprache der Nachrichtenseite): Krieg, Invasion, Ukraine, Kiew, Odessa, Charkiw, Cherson, Mariupol, Luhansk, Tschernihiw, Donezk, Lwiw, Tschernobyl, Selenskyj, Klitschko, Putin, Kreml, Russland.</p>

		<h2>Medien in
			<select id="selectCountry">
				<option value="de">Deutschland</option>
				<option value="fr">Frankreich</option>
				<option value="us">USA</option>
				<option value="uk">Großbritannien</option>
				<option value="pl">Polen</option>
				<option value="fi">Finnland</option>
				<option value="ru">Russland</option>
			</select>
		</h2>

		<div id="linechartCountry"></div>

		<h2>Ländervergleich</h2>
		<div id="linechartCountries"></div>

		<script type="text/javascript">
			setTimeout(start, 0);

			async function start() {
				let data = await d3.json('./data.json');

				let dateMin = Date.now(), dateMax = false;
				data.forEach(e => {
					e.list = e.list.filter(e => e.value);

					let avg = e.list.reduce((s,e) => s += e.value ?? 0, 0);
					avg /= e.list.length;

					e.list.forEach(p => {
						p.xValue = new Date(p.date);
						if (dateMin > p.xValue) dateMin = p.xValue;
						if (dateMax < p.xValue) dateMax = p.xValue;

						p.yValue = p.value/avg;
					})

					e.list.sort((a,b) => a.xValue - b.xValue);

					e.list.forEach(p1 => {
						let valSum = 0, weightSum = 0;
						e.list.forEach(p2 => {
							let weight = Math.exp(-Math.pow((p2.xValue - p1.xValue)/86400000*0.5, 2));
							valSum += weight*p2.yValue;
							weightSum += weight;
						})
						p1.ySmooth = valSum/weightSum;
					})
				})



				let selectCountry = d3.select('#selectCountry');
				selectCountry.on('change', () => {
					let selected = selectCountry.node().selectedOptions[0];
					let name = selected.innerText;
					let code = selected.value;
					drawCountry(name, code);
				})
				selectCountry.dispatch('change')

				drawAllCountries();

				function drawAllCountries() {
					let countries = [];
					selectCountry.selectAll('option').each(function (a,b,c) {
						let name = this.innerText;
						let code = this.value;

						let list = new Map();
						data.forEach(e => {
							if (e.medium.country !== code) return;
							e.list.forEach(p => {
								if (!list.has(p.date)) list.set(p.date, { xValue:p.xValue, ySmooth:0, count:0 })
								let p2 = list.get(p.date);
								p2.ySmooth += p.ySmooth;
								p2.count ++;
							})
						})
						list = Array.from(list.values());
						list.forEach(p => p.ySmooth /= p.count)
						countries.push({ name, color:'#000', opacity:0.3, list })
					});
					draw('#linechartCountries', countries);
				}



				function drawCountry(name, cc) {
					let data1 = data.filter(e => e.medium.country === cc)
						.map(e => Object.assign({}, e, {name:e.medium.name, dots:true, opacity:0.15, color: '#0069b4'}))
					let list = new Map();
					data1.forEach(e => e.list.forEach(p => {
						if (!list.has(p.date)) list.set(p.date, { xValue:p.xValue, ySmooth:0, count:0 })
						let p2 = list.get(p.date);
						p2.ySmooth += p.ySmooth;
						p2.count ++;
					}))
					list = Array.from(list.values());
					list.forEach(p => p.ySmooth /= p.count)
					data1.push({ name, color:'#000', opacity:1, list })
					draw('#linechartCountry', data1);

				}

				function draw(query, lines) {

					const margin = {top:10, right:180, bottom:30, left:60};

					const wrapper = d3.select(query);
					const width  = Math.round(wrapper.node().offsetWidth - margin.left - margin.right);
					const height = Math.round(width*0.618);

					const canvasWidth  = Math.ceil(width  + margin.left + margin.right);
					const canvasHeight = Math.ceil(height + margin.top  + margin.bottom);

					wrapper
						.style('height', canvasHeight+'px')
						.style('overflow', 'hidden')

					wrapper.select('svg').remove();

					let svg = wrapper.append('svg')
  						.attr('width',  canvasWidth)
  						.attr('height', canvasHeight)
  						.style('width',  canvasWidth+'px')
  						.style('height', canvasHeight+'px')

					// Add X axis --> it is a date format
					let x = d3.scaleLinear()
						.domain([dateMin, dateMax])
						.range([0, width]);

					let y = d3.scaleLinear()
						.domain([0, 3])
						.range([height, 0]);

					svg.append('g')
						.attr('transform', `translate(${margin.left},${canvasHeight-margin.bottom})`)
						.call(d3.axisBottom(x).tickFormat(d3.timeFormat('%e %b')));

					svg.append('g')
						.attr('transform', `translate(${margin.left},${margin.top})`)
						.call(d3.axisLeft(y).ticks(3,'%'))
						.append('line')
							.attr('x1', 0)
							.attr('y1', y(1))
							.attr('x2', width )
							.attr('y2', y(1))
							.attr('stroke', '#000')
							.attr('opacity', 0.2)
							.attr('stroke-dasharray', '2 4')


					let canvas = svg.append('g')
							.attr('transform', `translate(${margin.left},${margin.top})`)

					lines.forEach(line => {
						line.list.sort((a,b) => a.xValue - b.xValue);
						line.lastPoint = line.list[line.list.length-1];
						line.lastY = y(line.lastPoint.ySmooth);
						line.legendY = line.lastY;
					})

					fixY(lines, 'legendY', 15);

					// Draw the line
					lines.forEach(line => {
						line.path = d3.line()
							.curve(d3.curveBasis)
							//.curve(d3.curveBundle.beta(0.7))
							.x(d => x(d.xValue))
							.y(d => y(d.ySmooth))
							(line.list);

						line.wrapper = canvas.append('g')
							.on('mouseover', () => {
								line.curve.attr('opacity', 1);
								line.annotations.attr('opacity', 1)
							})
							.on('mouseout',  () => {
								line.curve.attr('opacity', line.opacity);
								line.annotations.attr('opacity', 0)
							})

						line.wrapper.append('path')
							.attr('fill', 'none')
							.attr('stroke', '#f00')
							.attr('opacity', 0)
							.attr('stroke-width', 12)
							.attr('d', line.path)

						line.curve = line.wrapper.append('g')
							.attr('opacity', line.opacity)

						line.curve.append('path')
							.attr('fill', 'none')
							.attr('stroke', line.color)
							.attr('stroke-width', 1.5)
							.attr('d', line.path)

						line.curve.append('text')
							.attr('fill', line.color)
							.attr('x', width+20)
							.attr('y', line.legendY)
							.attr('dy', '0.5em')
							.attr('text-anchor', 'start')
							.attr('font-size', 12)
							.attr('font-family', 'sans-serif')

							.text(line.name)

						line.annotations = canvas
							.append('g')
								.attr('opacity', 0);

						let dx = 20;
						let dy = line.legendY-line.lastY;
						let f = 5/Math.sqrt(dx*dx + dy*dy);
						line.annotations.append('line')
							.attr('x1', width + dx*f)
							.attr('x2', width + dx - dx*f)
							.attr('y1', line.lastY + dy*f)
							.attr('y2', line.legendY - dy*f)
							.attr('stroke-dasharray', '1.5')
							.attr('stroke', line.color)

						if (line.dots) {
							line.annotations.selectAll('dot')
								.data(line.list)
								.enter()
								.append('circle')
									.attr('cx', d => x(d.xValue))
									.attr('cy', d => y(d.yValue))
									.attr('r', 1.5)
									.attr('fill', line.color)
									.attr('stroke', 'none');
						}
					})
				}

				function fixY(list, key, minDistance) {
					let entries = list.map(e => ({y0:e[key], entry:e}));
					entries.sort((a,b) => a.y0 - b.y0);

					let y = null;
					entries.forEach(e => e.y1 = y = Math.max(e.y0, (y ?? -10e10)+minDistance))

					entries.reverse();
					y = null;
					entries.forEach(e => e.y2 = y = Math.min(e.y0, (y ?? 10e10)-minDistance))

					entries.forEach(e => e.entry[key] = (e.y1 + e.y2)/2)
				}
			}
		</script>
	</body>
</html>
