<!DOCTYPE html>
<html lang="de">
	<head>
		<meta charset="utf-8">
		<meta name=viewport content="width=device-width, initial-scale=1">
		<title>Wie lange interessiert uns der Krieg?</title>

		<meta name="twitter:card" content="summary_large_image">
		<meta name="twitter:creator" content="@michaelkreil">
		<meta name="twitter:title" content="Wie lange interessiert uns der Krieg?">
		<meta name="twitter:description" content="Der Krieg wird Alltag und die Berichterstattung nimmt ab. Passiert das in allen Ländern in gleichem Maße?">
		<meta name="twitter:image" content="https://michaelkreil.github.io/ukraine-news/screenshot.png">

		<script src="d3.min.js" charset="utf-8"></script>
		<style>
			body {
				font-family: sans-serif;
				font-size: 14px;
				margin: 0 0 100px;
				line-height: 1.3em
			}
			h1 {
				max-width: calc(100vw - 40px);
				text-align: center;
				margin: 100px auto 50px;
			}
			h2 {
				max-width: calc(100vw - 40px);
				text-align: center;
				font-size: 18px;
				margin: 50px auto 20px;
			}
			p {
				max-width: min(600px, calc(100vw - 40px));
				margin: 30px auto;
			}
			select {
				font-size: 20px;
			}
		</style>
	</head>
	<body>
		<h1>Wie lange interessiert uns der Krieg?</h1>

		<p>Der Krieg in der Ukraine wird vorraussichtlich Monate, vielleicht sogar Jahre andauern. Weil viele Menschen nicht direkt betroffen sind, können wir davon ausgehen, dass in unserer Gesellschaft ein Gewöhnungseffekt eintreten wird. Im gleichen Maße wird die Berichterstattung abnehmen und andere Themen werden relevanter.
		<br>Diesen Effekt möchte ich beobachten und dabei unterschiedliche Medien in unterschiedlichen Ländern vergleichen.</p>

		<p>Dazu werden die Frontseiten zahlreicher Nachrichtenseiten täglich von archive.org geladen und die Häufigkeit thematischer Begriffe gezählt. Diese Begriffe sind: Krieg, Invasion, Panzer, Ukraine, Kiew, Odessa, Charkiw, Cherson, Mariupol, Luhansk, Tschernihiw, Donezk, Lwiw, Tschernobyl, Selenskyj, Klitschko, Putin, Kreml, Russland (natürlich in der jeweiligen Landessprache der Nachrichtenseite und nur wenn sinnvoll).</p>

		<h2>Berichterstattung über den Ukrainekrieg in
			<select id="selectCountry">
				<option value="de">Deutschland</option>
				<option value="fr">Frankreich</option>
				<option value="us">USA</option>
				<option value="uk">Großbritannien</option>
				<option value="pl">Polen</option>
				<option value="fi">Finnland</option>
				<option value="ru">Russland</option>
			</select>
		</h2>

		<div id="linechartCountry"></div>

		<h2>Ländervergleich</h2>
		<div id="linechartCountries"></div>

		<p>
			Natürlich lässt sich dieser Ansatz in mehrere Richtungen verbessern. Man könnte weitere Medien hinzufügen, weitere Länder und weitere Sprachen.
		</p>
		<p>
			Auch die Methodik, die Anzahl der relevanten Wörter zu zählen, ließe sich verbessern: Das Wort "Kreml" ist aktuell in der deutschen Berichterstattung ein sicherer Marker, dass es um den Krieg in der Ukraine geht. Jedoch in russischen Medien gibt es auch andere Themen, die das Wort "Kreml" enthalten. Dort ist "Kiew" ein sicherer Marker, was wiederum nicht für Medien in Kiew gilt, usw.<br>
			Kurz: Ich suche Verbesserungsvorschläge, wie man die Berichterstattung besser nach Themen kategorisieren kann, und das für unterschiedliche Medien, Sprachen und Länder.
		</p>
		<p>
			Code und Daten befinden sich wie immer auf GitHub: <a href="https://github.com/michaelkreil/ukraine-news">github.com/michaelkreil/ukraine-news</a>
		</p>

		<script type="text/javascript">
			setTimeout(start, 0);

			async function start() {
				let data = await d3.json('./data.json');

				let dateMin = Date.now(), dateMax = false;
				data.forEach(e => {
					e.list = e.list.filter(e => e.value);

					let avg = e.list.reduce((s,e) => s += e.value ?? 0, 0);
					avg /= e.list.length;

					e.list.forEach(p => {
						p.xValue = new Date(p.date);
						if (dateMin > p.xValue) dateMin = p.xValue;
						if (dateMax < p.xValue) dateMax = p.xValue;

						p.yValue = p.value/avg;
					})

					e.list.sort((a,b) => a.xValue - b.xValue);

					e.list.forEach(p1 => {
						let valSum = 0, weightSum = 0;
						e.list.forEach(p2 => {
							let weight = Math.exp(-Math.pow((p2.xValue - p1.xValue)/86400000*0.5, 2));
							valSum += weight*p2.yValue;
							weightSum += weight;
						})
						p1.ySmooth = valSum/weightSum;
					})
				})



				let selectCountry = d3.select('#selectCountry');
				selectCountry.on('change', () => {
					let selected = selectCountry.node().selectedOptions[0];
					let name = selected.innerText;
					let code = selected.value;
					drawCountry(name, code);
				})
				selectCountry.dispatch('change')

				drawAllCountries();

				function drawAllCountries() {
					let countries = [];
					selectCountry.selectAll('option').each(function (a,b,c) {
						let name = this.innerText;
						let code = this.value;

						let list = new Map();
						data.forEach(e => {
							if (e.medium.country !== code) return;
							e.list.forEach(p => {
								if (!list.has(p.date)) list.set(p.date, { xValue:p.xValue, ySmooth:0, count:0 })
								let p2 = list.get(p.date);
								p2.ySmooth += p.ySmooth;
								p2.count ++;
							})
						})
						list = Array.from(list.values());
						list.forEach(p => p.ySmooth /= p.count)
						countries.push({ name, color:'#000', opacity:0.3, list })
					});
					draw('#linechartCountries', countries);
				}



				function drawCountry(name, cc) {
					let data1 = data.filter(e => e.medium.country === cc)
						.map(e => Object.assign({}, e, {name:e.medium.name, dots:true, opacity:0.15, color: '#0069b4'}))
					let list = new Map();
					data1.forEach(e => e.list.forEach(p => {
						if (!list.has(p.date)) list.set(p.date, { xValue:p.xValue, ySmooth:0, count:0 })
						let p2 = list.get(p.date);
						p2.ySmooth += p.ySmooth;
						p2.count ++;
					}))
					list = Array.from(list.values());
					list.forEach(p => p.ySmooth /= p.count)
					data1.push({ name, color:'#000', opacity:1, list })
					draw('#linechartCountry', data1);

				}

				function draw(query, lines) {

					const margin = {top:10, right:180, bottom:30, left:40};

					const wrapper = d3.select(query);
					let offsetWidth = wrapper.node().offsetWidth;
					let scale  = 1;
					if (offsetWidth < 700) {
						scale = offsetWidth/700;
						offsetWidth = 700;
					}
					const width  = Math.round(offsetWidth - margin.left - margin.right);
					const height = Math.round(width*0.618);

					const canvasWidth  = Math.ceil(width  + margin.left + margin.right);
					const canvasHeight = Math.ceil(height + margin.top  + margin.bottom);

					wrapper
						.style('height', Math.round(scale*canvasHeight)+'px')
						.style('overflow', 'hidden')

					wrapper.select('svg').remove();

					let svg = wrapper.append('svg')
					 	.attr('xmlns', 'http://www.w3.org/2000/svg')
  						.attr('width', '100%')
  						.attr('viewBox', [0,0,canvasWidth,canvasHeight].join(' '))
						.attr('preserveAspectRatio', 'xMidYMid meet');

					// Add X axis --> it is a date format
					let x = d3.scaleLinear()
						.domain([dateMin, dateMax])
						.range([0, width]);

					let y = d3.scaleLinear()
						.domain([0, 3])
						.range([height, 0]);

					svg.append('g')
						.attr('transform', `translate(${margin.left},${canvasHeight-margin.bottom})`)
						.call(d3.axisBottom(x).tickFormat(d3.timeFormat('%e %b')));

					svg.append('g')
						.attr('transform', `translate(${margin.left},${margin.top})`)
						.call(d3.axisLeft(y).ticks(3,'%'))
						.append('line')
							.attr('x1', 0)
							.attr('y1', y(1))
							.attr('x2', width )
							.attr('y2', y(1))
							.attr('stroke', '#000')
							.attr('opacity', 0.2)
							.attr('stroke-dasharray', '2 4')


					let canvas = svg.append('g')
							.attr('transform', `translate(${margin.left},${margin.top})`)

					lines.forEach(line => {
						line.list.sort((a,b) => a.xValue - b.xValue);
						line.lastPoint = line.list[line.list.length-1];
						line.lastY = y(line.lastPoint.ySmooth);
						line.legendY = line.lastY;
					})

					fixY(lines, 'legendY', 15);

					// Draw the line
					lines.forEach(line => {
						line.path = d3.line()
							.curve(d3.curveBasis)
							//.curve(d3.curveBundle.beta(0.7))
							.x(d => x(d.xValue))
							.y(d => y(d.ySmooth))
							(line.list);

						line.wrapper = canvas.append('g')
							.on('mouseover', () => {
								line.curve.attr('opacity', 1);
								line.annotations.attr('opacity', 1)
							})
							.on('mouseout',  () => {
								line.curve.attr('opacity', line.opacity);
								line.annotations.attr('opacity', 0)
							})

						line.wrapper.append('path')
							.attr('fill', 'none')
							.attr('stroke', '#f00')
							.attr('opacity', 0)
							.attr('stroke-width', 12)
							.attr('d', line.path)

						line.curve = line.wrapper.append('g')
							.attr('opacity', line.opacity)

						line.curve.append('path')
							.attr('fill', 'none')
							.attr('stroke', line.color)
							.attr('stroke-width', 1.5)
							.attr('d', line.path)

						line.curve.append('text')
							.attr('fill', line.color)
							.attr('x', width+20)
							.attr('y', line.legendY)
							.attr('dy', '0.5em')
							.attr('text-anchor', 'start')
							.attr('font-size', 12)
							.attr('font-family', 'sans-serif')

							.text(line.name)

						line.annotations = canvas
							.append('g')
								.attr('opacity', 0);

						let dx = 20;
						let dy = line.legendY-line.lastY;
						let f = 5/Math.sqrt(dx*dx + dy*dy);
						line.annotations.append('line')
							.attr('x1', width + dx*f)
							.attr('x2', width + dx - dx*f)
							.attr('y1', line.lastY + dy*f)
							.attr('y2', line.legendY - dy*f)
							.attr('stroke-dasharray', '1.5')
							.attr('stroke', line.color)

						if (line.dots) {
							line.annotations.selectAll('dot')
								.data(line.list)
								.enter()
								.append('circle')
									.attr('cx', d => x(d.xValue))
									.attr('cy', d => y(d.yValue))
									.attr('r', 1.5)
									.attr('fill', line.color)
									.attr('stroke', 'none');
						}
					})
				}

				function fixY(list, key, minDistance) {
					let entries = list.map(e => ({y0:e[key], entry:e}));
					entries.sort((a,b) => a.y0 - b.y0);

					let y = null;
					entries.forEach(e => e.y1 = y = Math.max(e.y0, (y ?? -10e10)+minDistance))

					entries.reverse();
					y = null;
					entries.forEach(e => e.y2 = y = Math.min(e.y0, (y ?? 10e10)-minDistance))

					entries.forEach(e => e.entry[key] = (e.y1 + e.y2)/2)
				}
			}
		</script>
		<img src="https://count.nachtrag.de/ukraine-news" width="0" height="0">
	</body>
</html>
