<!DOCTYPE html>
<html lang="en" dir="ltr">
	<head>
		<meta charset="utf-8">
		<title></title>
		<script src="d3.min.js" charset="utf-8"></script>
	</head>
	<body>
		<h1></h1>

		<h2></h2>
		<div id="linechart1"></div>

		<h2></h2>
		<div id="linechart2"></div>

		<h2></h2>
		<div id="linechart3"></div>

		<h2></h2>
		<div id="linechart4"></div>

		<h2></h2>
		<div id="linechart5"></div>

		<h2></h2>
		<div id="linechart6"></div>

		<h2></h2>
		<div id="linechart7"></div>

		<script type="text/javascript">
			setTimeout(start, 0);

			async function start() {
				let data = await d3.json('./data.json');

				let dateMin = Date.now(), dateMax = false;
				data.forEach(e => {
					e.list = e.list.filter(e => e.value);

					let avg = e.list.reduce((s,e) => s += e.value ?? 0, 0);
					avg /= e.list.length;

					e.list.forEach(p => {
						p.xValue = new Date(p.date);
						if (dateMin > p.xValue) dateMin = p.xValue;
						if (dateMax < p.xValue) dateMax = p.xValue;

						p.yValue = p.value/avg;
					})

					e.list.sort((a,b) => a.xValue - b.xValue);

					e.list.forEach(p1 => {
						let valSum = 0, weightSum = 0;
						e.list.forEach(p2 => {
							let weight = Math.exp(-Math.pow((p2.xValue - p1.xValue)/86400000*0.5, 2));
							valSum += weight*p2.yValue;
							weightSum += weight;
						})
						p1.ySmooth = valSum/weightSum;
					})
				})

				drawCountry('#linechart1', 'Deutschland', 'de')
				drawCountry('#linechart2', 'Frankreich', 'fr')
				drawCountry('#linechart3', 'Polen', 'pl')
				drawCountry('#linechart4', 'GroÃŸ Britannien', 'uk')
				drawCountry('#linechart5', 'Vereinigte Staaten von A', 'us')



				function drawCountry(query, name, cc) {
					let data1 = data.filter(e => e.medium.country === cc)
						.map(e => Object.assign({}, e, {name:e.medium.name, dots:true, opacity:0.1, color: '#0069b4'}))
					let list = new Map();
					data1.forEach(e => e.list.forEach(p => {
						if (!list.has(p.date)) list.set(p.date, { xValue:p.xValue, ySmooth:0, count:0 })
						let p2 = list.get(p.date);
						p2.ySmooth += p.ySmooth;
						p2.count ++;
					}))
					list = Array.from(list.values());
					list.forEach(p => p.ySmooth /= p.count)
					data1.push({ name, color:'#000', opacity:1, list })
					draw(query, data1);

				}

				function draw(query, lines) {

					const margin = {top:10, right:180, bottom:30, left:60};

					const wrapper = d3.select(query);
					const width  = Math.round(wrapper.node().offsetWidth - margin.left - margin.right);
					const height = Math.round(width*0.618);

					const canvasWidth  = Math.ceil(width  + margin.left + margin.right);
					const canvasHeight = Math.ceil(height + margin.top  + margin.bottom);

					wrapper
						.style('height', canvasHeight+'px')
						.style('overflow', 'hidden')

					let svg = wrapper.append('svg')
  						.attr('width',  canvasWidth)
  						.attr('height', canvasHeight)
  						.style('width',  canvasWidth+'px')
  						.style('height', canvasHeight+'px')

					// Add X axis --> it is a date format
					let x = d3.scaleLinear()
						.domain([dateMin, dateMax])
						.range([0, width]);

					let y = d3.scaleLinear()
						.domain([0, 3])
						.range([height, 0]);

					svg.append('g')
						.attr('transform', `translate(${margin.left},${canvasHeight-margin.bottom})`)
						.call(d3.axisBottom(x).tickFormat(d3.timeFormat('%b-%e')));

					svg.append('g')
						.attr('transform', `translate(${margin.left},${margin.top})`)
						.call(d3.axisLeft(y).ticks(3,'%'))
						.append('line')
							.attr('x1', 0)
							.attr('y1', y(1))
							.attr('x2', width )
							.attr('y2', y(1))
							.attr('stroke', '#000')
							.attr('opacity', 0.2)
							.attr('stroke-dasharray', '2 4')


					let canvas = svg.append('g')
							.attr('transform', `translate(${margin.left},${margin.top})`)

					lines.forEach(line => {
						line.list.sort((a,b) => a.xValue - b.xValue);
						line.lastPoint = line.list[line.list.length-1];
						line.lastY = y(line.lastPoint.ySmooth);
						line.legendY = line.lastY;
					})

					fixY(lines, 'legendY', 15);

					// Draw the line
					lines.forEach(line => {
						line.path = d3.line()
							.curve(d3.curveBasis)
							//.curve(d3.curveBundle.beta(0.7))
							.x(d => x(d.xValue))
							.y(d => y(d.ySmooth))
							(line.list);

						line.wrapper = canvas.append('g')
							.on('mouseover', () => {
								line.curve.attr('opacity', 1);
								line.annotations.attr('opacity', 1)
							})
							.on('mouseout',  () => {
								line.curve.attr('opacity', line.opacity);
								line.annotations.attr('opacity', 0)
							})

						line.wrapper.append('path')
							.attr('fill', 'none')
							.attr('stroke', '#f00')
							.attr('opacity', 0)
							.attr('stroke-width', 12)
							.attr('d', line.path)

						line.curve = line.wrapper.append('g')
							.attr('opacity', line.opacity)

						line.curve.append('path')
							.attr('fill', 'none')
							.attr('stroke', line.color)
							.attr('stroke-width', 1.5)
							.attr('d', line.path)

						line.curve.append('text')
							.attr('fill', line.color)
							.attr('x', width+20)
							.attr('y', line.legendY)
							.attr('dy', '0.5em')
							.attr('text-anchor', 'start')
							.attr('font-size', 12)
							.attr('font-family', 'sans-serif')

							.text(line.name)

						line.annotations = canvas
							.append('g')
								.attr('opacity', 0);

						let dx = 20;
						let dy = line.legendY-line.lastY;
						let f = 5/Math.sqrt(dx*dx + dy*dy);
						line.annotations.append('line')
							.attr('x1', width + dx*f)
							.attr('x2', width + dx - dx*f)
							.attr('y1', line.lastY + dy*f)
							.attr('y2', line.legendY - dy*f)
							.attr('stroke-dasharray', '1.5')
							.attr('stroke', line.color)

						if (line.dots) {
							line.annotations.selectAll('dot')
								.data(line.list)
								.enter()
								.append('circle')
									.attr('cx', d => x(d.xValue))
									.attr('cy', d => y(d.yValue))
									.attr('r', 1.5)
									.attr('fill', line.color)
									.attr('stroke', 'none');
						}
					})
				}

				function fixY(list, key, minDistance) {
					let entries = list.map(e => ({y0:e[key], entry:e}));
					entries.sort((a,b) => a.y0 - b.y0);

					let y = null;
					entries.forEach(e => e.y1 = y = Math.max(e.y0, (y ?? -10e10)+minDistance))

					entries.reverse();
					y = null;
					entries.forEach(e => e.y2 = y = Math.min(e.y0, (y ?? 10e10)-minDistance))

					entries.forEach(e => e.entry[key] = (e.y1 + e.y2)/2)
				}
			}
		</script>
	</body>
</html>
